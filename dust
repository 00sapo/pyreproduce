#!/bin/env sh

# POSIX-compliant script for setting up your shell
thisdir=$(realpath $(dirname $0))
DUSTDIR=${thisdir}/dustenv
PYENVDIR=${DUSTDIR}/pyenv
. ${DUSTDIR}/pyenv-source.sh

# setup_pypackages() {
#   export PYTHONPATH="$(pyenv prefix)/lib:$PYTHONPATH"
# }
dust_sync() {
  pyenv exec pdm export -f requirements requirements.txt
  pyenv exec python -m pip install -r requirements.txt
}

# backup status of installed packages for later
# pypackages_before=$(ls -lR ${thisdir}/__pypackages__/ 2>/dev/null)
pyenv_before=$(ls -lR $(pyenv prefix)/lib/ 2>/dev/null)

# special command: add
if test "$1" = "add"
then
  # setup_pypackages
  pyenv exec pdm add --no-sync "$@"
  dust_sync
  check_changes=0
elif test "$1" = "remove"
then
  # setup_pypackages
  pyenv exec pdm remove --no-sync "$@"
  dust_sync
  check_changes=0
elif test "$1" = "update"
then
  # setup_pypackages
  pyenv exec pdm update --no-sync "$@"
  dust_sync
  check_changes=0
elif test "$1" = "pdm"
then
  pyenv exec "$@"
  dust_sync
  check_changes=0
elif test "$1" = "exec"
then
  pyenv exec "${@:2}"
  dust_sync
  check_changes=1
else
  # setup_pypackages
  pyenv exec python "$@"
  check_changes=1
fi

# check if some package was modified
if [ "$check_changes" = "1" ]
then
  pyenv_after=$(ls -lR $(pyenv prefix)/lib/ 2>/dev/null)
  if  [ "$pyenv_after" != "$pyenv_before" ]; then
    echo "DUST MESSAGE: Detected changes, do you want that we update requirements.txt and pyproject.toml? This will produce a very long and meaningless pyproject.toml! [y/n]"
    read answer
   # this grammar (the #[] operator) means that the variable $answer where any Y or y in
   # 1st position will be dropped if they exist.
    if [ "$answer" != "${answer#[Yy]}" ]
    then
      pyenv exec python -m pip freeze > requirements.txt 2>/dev/null
      pyenv exec pdm import -f requirements requirements.txt
      pyenv exec python -m pip install -r requirements.txt
    fi
  fi
fi

if test $ERROR
then
  echo "Some error happened! Have you run 'install.sh'?"
  exit 1
fi
